#### 简单总结你实现的功能
实现在某个页表下虚拟地址向物理地址的转换，检查某个页表下\[start_va,end_va\)内是否存在被映射的区域，检查某个页表下\[start_va,end_va\)内是否存在未被映射的区域，为memory_set增加了移除type为framed的区域的移除。实现了简易的sys_map和sys_unmap

#### 完成问答题
1. 请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？
答：10位保留位，44位的物理页号位，2位操作系统保留位，D位表示是否是脏页，A位表示上次A位被清除以来是否被访问过，G位表示是否对所有虚拟地址空间有效，U位表示是否是用户页面，RWX分别表示该页是否可读取可写入可访问，V位表示该页是否有效

2. 缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断， 告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程。
请问哪些异常可能是缺页导致的？
答：store access fault, store page fault, load access fault, load page fault

发生缺页时，描述相关重要寄存器的值
scause存取了异常原因，sepc保存了缺页指令地址，satp保存了发生缺页页表的token

缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。 比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 os 并不会马上这样做， 而是会保存 .text 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。
这样做有哪些好处？
节省了内存，因为程序加载后并不会被马上运行，这部分程序保存在内存中是不必要的

其实，我们的 mmap 也可以采取 Lazy 策略，比如：一个用户进程先后申请了 10G 的内存空间， 然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。
处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)
一个页表项为8字节,一页为4kB,10g内存页面需要10g/4kB≈2m页，约需要三级页表的十个条目，需要10*512*512*8≈10m

请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。
答：标记这些页面为lazy页面，缺页时若为lazy页面则为其分配新页面

缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。
此时页面失效如何表现在页表项(PTE)上
答：页表项v位置0

3. 为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说， 用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。 (备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 KPTI )

在单页表情况下，如何更换页表？
答：向satp写入变换后的页表ppn

单页表情况下，如何控制用户态无法访问内核页面？
答：将内核页面的用户位置0

单页表有何优势？
答：trap不需要更换页表，更方便编程。能不更换页表直接访问内核资源，效率可能会更高

双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表
答：需要系统调用时更换页表。进入内核后就开启分页

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

    无

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

    xv6-book以及mit6.828课程

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

